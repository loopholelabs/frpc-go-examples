// Code generated by fRPC Go v0.6.0, DO NOT EDIT.
// source: echo.proto

package echo

import (
	"errors"
	"github.com/loopholelabs/polyglot-go"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"
)

var (
	NilDecode = errors.New("cannot decode into a nil root struct")
)

type Request struct {
	error  error
	ignore bool

	Message string
}

func NewRequest() *Request {
	return &Request{}
}

func (x *Request) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Request) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Bool(x.ignore)
		polyglot.Encoder(b).String(x.Message)
	}
}

func (x *Request) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Request) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.ignore, err = d.Bool()
	if err != nil {
		return err
	}
	x.Message, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type Response struct {
	error  error
	ignore bool

	Message string
}

func NewResponse() *Response {
	return &Response{}
}

func (x *Response) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Response) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Bool(x.ignore)
		polyglot.Encoder(b).String(x.Message)
	}
}

func (x *Response) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Response) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.ignore, err = d.Bool()
	if err != nil {
		return err
	}
	x.Message, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type EchoService interface {
	Echo(context.Context, *Request) (*Response, error)
}

type Server struct {
	*frisbee.Server
}

func NewServer(echoService EchoService, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			if req.ignore {
				echoService.Echo(ctx, req)
				return
			}
			var res *Response
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = echoService.Echo(ctx, req)
			if err != nil {
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	s, err = &Server{
		Server: fsrv,
	}, nil
	return s, err
}

type subEchoServiceClient struct {
	client         *frisbee.Client
	nextEcho       uint16
	nextEchoMu     sync.RWMutex
	inflightEcho   map[uint16]chan *Response
	inflightEchoMu sync.RWMutex
}
type Client struct {
	*frisbee.Client
	EchoService *subEchoServiceClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.EchoService.inflightEchoMu.RLock()
		if ch, ok := c.EchoService.inflightEcho[incoming.Metadata.Id]; ok {
			c.EchoService.inflightEchoMu.RUnlock()
			res := NewResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.EchoService.inflightEchoMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.EchoService = new(subEchoServiceClient)
	c.EchoService.client = c.Client
	c.EchoService.inflightEcho = make(map[uint16]chan *Response)
	c.EchoService.nextEchoMu.Lock()
	c.EchoService.nextEcho = 0
	c.EchoService.nextEchoMu.Unlock()
	c.EchoService.inflightEcho = make(map[uint16]chan *Response)
	return c, nil
}

func (c *subEchoServiceClient) Echo(ctx context.Context, req *Request) (res *Response, err error) {
	ch := make(chan *Response, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextEchoMu.Lock()
	c.nextEcho += 1
	id := c.nextEcho
	c.nextEchoMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightEchoMu.Lock()
	c.inflightEcho[id] = ch
	c.inflightEchoMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightEchoMu.Lock()
	delete(c.inflightEcho, id)
	c.inflightEchoMu.Unlock()
	packet.Put(p)
	return
}
